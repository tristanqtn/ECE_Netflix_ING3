package Modele;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.Vector;

import Entite.ContenuCinematographique;
import Entite.Documentaire;
import Entite.Episode;
import Entite.Film;
import Entite.Membre;
import Entite.Saison;
import Entite.Serie;
import Entite.Visionnage;

/**
 * 
 * @author tristan querton
 * 
 *         Cette classe exploite la classe BDD_interface pour extraire de la
 *         base des informations ou pour y ajouter des données. Cette classe est
 *         aussi responsable de la création des objets utilisés par le contoleur
 *         qui sont stockés dans la BDD.
 * 
 *         Le constructeur propose une fonction de RESET de la BDD qui la
 *         supprime et la regenere pour eviter les problème d'insertion.
 * 
 *         CETTE CLASSE NE DOIT PAS ETRE UTILISEE PAR AUTRE CHOSE QUE LA PARTIE
 *         CONTROLEUR
 * 
 *         Utilise la classe BDD_ScriptRunner de Clinton Begin
 *
 */

public class BDD_exploitant {

	private BDD_interface connexion;

	// CONSTRUCTEUR DE L'EXPLOITANT CONNECTANT SON INTERFACE AU SERVICE LOCAL mySQL
	public BDD_exploitant(String utilisateur, String mdp, boolean reset_BDD) throws SQLException {
		connexion = new BDD_interface(utilisateur, mdp); // allocation de l'interface
		if (reset_BDD) {// si l'utilisateur choisi d'activer le reset
			BDD_suppression_schema(); // suppression de l'ancienne BDD
			BDD_generation_schema();// execution du script de generation et remplissage sdu schema
		}
	}

	// FONCTION QUI SUPPRIME LA BASE DE DONNEE
	public void BDD_suppression_schema() throws SQLException {
		connexion.executer_maj("DROP DATABASE `netflix`;"); // suppression de l'ancienne BDD
	}

	// FONCTION QUI SUPPRIME LA BASE DE DONNEE
	public void BDD_generation_schema() throws SQLException {
		connexion.executer_script_sql("/sql/generation_schema.sql"); // execution du script de generation du schema
		connexion.executer_script_sql("/sql/donnees.sql"); // execution du scirpt de remplissage du schema
	}

	// REQUETE D'EXTRACTION DES FILMS DEPUIS LA BDD
	private ResultSet obtenir_films() {
		return connexion.executer_requete("SELECT * FROM NETFLIX.films");// rendu du resultat de la requete
	}

	// REQUETE D'EXTRACTION DES DOCUMENTAIRES DEPUIS LA BDD
	private ResultSet obtenir_documentaires() {
		return connexion.executer_requete("SELECT * FROM NETFLIX.documentaires"); // rendu du resultat de la requete
	}

	// REQUETE D'EXTRACTION DES EPISODES DEPUIS LA BDD
	private ResultSet obtenir_episodes() {
		return connexion.executer_requete("SELECT * FROM NETFLIX.episodes");// rendu du resultat de la requete
	}

	// REQUETE D'EXTRACTION DES MEMBRES DEPUIS LA BDD
	private ResultSet obtenir_membres() {
		return connexion.executer_requete("SELECT * FROM NETFLIX.membres");// rendu du resultat de la requete
	}

	// REQUETE D'EXTRACTION DES SAISONS DEPUIS LA BDD
	private ResultSet obtenir_saisons() {
		return connexion.executer_requete("SELECT * FROM NETFLIX.saisons");// rendu du resultat de la requete
	}

	// REQUETE D'EXTRACTION DES SERIES DEPUIS LA BDD
	private ResultSet obtenir_series() {
		return connexion.executer_requete("SELECT * FROM NETFLIX.series");// rendu du resultat de la requete
	}

	// REQUETE D'EXTRACTION DES VISIONNAGES DEPUIS LA BDD
	private ResultSet obtenir_visionnages() {
		return connexion.executer_requete("SELECT * FROM NETFLIX.visionnages");// rendu du resultat de la requete
	}

	@SuppressWarnings("unused")
	private void afficher_films() throws SQLException {

		ResultSet resultat = obtenir_films();

		while (resultat.next()) {

			Integer id = resultat.getInt("ID");
			Integer duree = resultat.getInt("duree");

			double note = resultat.getDouble("note");

			Date parution = resultat.getDate("parution");

			String realisateur = resultat.getString("realisateur");
			String acteur = resultat.getString("acteur");
			String genres = resultat.getString("genres");
			String titre = resultat.getString("titre");
			String synopsis = resultat.getString("synopsis");
			String video = resultat.getString("video");
			String trailer = resultat.getString("trailer");

			System.out.println(" ++ FILMS ++ ");
			System.out.println("ID: " + id);
			System.out.println("Duree: " + duree);

			System.out.println("Note: " + note);

			System.out.println("Date: " + parution);

			System.out.println("Realisateur: " + realisateur);
			System.out.println("Acteurs: " + acteur);
			System.out.println("Genres: " + genres);
			System.out.println("Titre: " + titre);
			System.out.println("Synopsis: " + synopsis);
			System.out.println("Video: " + video);
			System.out.println("Trailer: " + trailer);
		}
	}

	@SuppressWarnings("unused")
	private void afficher_documentaires() throws SQLException {
		ResultSet resultat = obtenir_documentaires();

		while (resultat.next()) {

			Integer id = resultat.getInt("ID");
			Integer duree = resultat.getInt("duree");

			double note = resultat.getDouble("note");

			Date parution = resultat.getDate("parution");

			String realisateur = resultat.getString("realisateur");
			String acteur = resultat.getString("acteur");
			String genres = resultat.getString("genres");
			String titre = resultat.getString("titre");
			String synopsis = resultat.getString("synopsis");
			String video = resultat.getString("video");
			String trailer = resultat.getString("trailer");

			System.out.println(" ++ DOCUMENTAIRES ++ ");
			System.out.println("ID: " + id);
			System.out.println("Duree: " + duree);

			System.out.println("Note: " + note);

			System.out.println("Date: " + parution);

			System.out.println("Realisateur: " + realisateur);
			System.out.println("Acteurs: " + acteur);
			System.out.println("Genres: " + genres);
			System.out.println("Titre: " + titre);
			System.out.println("Synopsis: " + synopsis);
			System.out.println("Video: " + video);
			System.out.println("Trailer: " + trailer);
		}
	}

	@SuppressWarnings("unused")
	private void afficher_series() throws SQLException {
		ResultSet resultat = obtenir_series();

		while (resultat.next()) {
			Integer id = resultat.getInt("ID");
			Integer duree = resultat.getInt("duree");
			Integer nb_saison = resultat.getInt("nombre_saison");
			Integer episode_en_cours = resultat.getInt("episode_en_cours");

			double note = resultat.getDouble("note");

			Date parution = resultat.getDate("parution");

			String realisateur = resultat.getString("realisateur");
			String acteur = resultat.getString("acteur");
			String genres = resultat.getString("genres");
			String titre = resultat.getString("titre");
			String synopsis = resultat.getString("synopsis");
			String video = resultat.getString("video");
			String trailer = resultat.getString("trailer");

			System.out.println(" ++ Serie ++ ");
			System.out.println("ID: " + id);
			System.out.println("Duree: " + duree);

			System.out.println("Note: " + note);

			System.out.println("Date: " + parution);

			System.out.println("NB Saisons: " + nb_saison);
			System.out.println("Episode en cours: " + episode_en_cours);

			System.out.println("Realisateur: " + realisateur);
			System.out.println("Acteurs: " + acteur);
			System.out.println("Genres: " + genres);
			System.out.println("Titre: " + titre);
			System.out.println("Synopsis: " + synopsis);
			System.out.println("Video: " + video);
			System.out.println("Trailer: " + trailer);
		}
	}

	@SuppressWarnings("unused")
	private void afficher_saisons() throws SQLException {
		// ResultSet is initially before the first data set
		ResultSet resultat = obtenir_saisons();

		while (resultat.next()) {
			Integer id = resultat.getInt("ID");
			Integer serie = resultat.getInt("serie");
			Integer num_saison = resultat.getInt("num_saison");
			Integer nombre_episode = resultat.getInt("nombre_episode");

			System.out.println(" ++ Saison ++ ");
			System.out.println("ID: " + id);
			System.out.println("Serie: " + serie);
			System.out.println("Num saison: " + num_saison);
			System.out.println("Nombre Episode: " + nombre_episode);
		}
	}

	@SuppressWarnings("unused")
	private void afficher_episodes() throws SQLException {
		ResultSet resultat = obtenir_episodes();

		while (resultat.next()) {

			Integer id = resultat.getInt("ID");
			Integer saison = resultat.getInt("saison");
			Integer duree = resultat.getInt("duree");
			Integer num_episode = resultat.getInt("numero_episode");

			double note = resultat.getDouble("note");

			Date parution = resultat.getDate("parution");

			String realisateur = resultat.getString("realisateur");
			String acteur = resultat.getString("acteur");
			String genres = resultat.getString("genres");
			String titre = resultat.getString("titre");
			String synopsis = resultat.getString("synopsis");
			String video = resultat.getString("video");
			String trailer = resultat.getString("trailer");

			System.out.println(" ++ Episode ++ ");
			System.out.println("ID: " + id);
			System.out.println("Duree: " + duree);
			System.out.println("Note: " + note);

			System.out.println("Date: " + parution);

			System.out.println("Saison: " + saison);
			System.out.println("Numero Episode: " + num_episode);

			System.out.println("Realisateur: " + realisateur);
			System.out.println("Acteurs: " + acteur);
			System.out.println("Genres: " + genres);
			System.out.println("Titre: " + titre);
			System.out.println("Synopsis: " + synopsis);
			System.out.println("Video: " + video);
			System.out.println("Trailer: " + trailer);
		}
	}

	@SuppressWarnings("unused")
	private void afficher_membres() throws SQLException {
		ResultSet resultat = obtenir_membres();

		while (resultat.next()) {
			Integer id = resultat.getInt("ID");
			Integer tel = resultat.getInt("telephone");

			double num_carte = resultat.getDouble("num_carte");

			String mail = resultat.getString("adresse_mail");
			String mdp = resultat.getString("mdp");
			String nom = resultat.getString("nom");
			String preferences = resultat.getString("preferences");
			String prenom = resultat.getString("prenom");

			System.out.println(" ++ DOCUMENTAIRES ++ ");
			System.out.println("ID: " + id);
			System.out.println("Tel: " + tel);

			System.out.println("CB: " + num_carte);

			System.out.println("Mail: " + mail);
			System.out.println("MDP: " + mdp);
			System.out.println("Nom: " + nom);
			System.out.println("Preference: " + preferences);
			System.out.println("Prenom: " + prenom);
		}
	}

	/// FONCTION D'ALLOCATION D'UN VECTEUR DE MEMBRE DEPUIS LES DONNEES DE LA BASE
	public Vector<Membre> extraire_membre_BDD() throws SQLException {
		Vector<Membre> vect = new Vector<Membre>(); // allocation du vecteur
		ResultSet resultat = obtenir_membres(); // recuperation des donnes de la table
		while (resultat.next()) {// allocation et ajout du nvl obj
			vect.add(new Membre(resultat.getInt("ID"), resultat.getString("nom"), resultat.getString("prenom"),
					resultat.getString("adresse_mail"), resultat.getLong("telephone"), resultat.getString("num_carte"),
					string_en_vector(resultat.getString("preferences")), resultat.getString("mdp"),
					resultat.getBoolean("admin"), resultat.getInt("temps_visionnage"), resultat.getInt("nb_film_vu"),
					resultat.getBoolean("soustitre"), resultat.getBoolean("reprise"), resultat.getString("qualite")));
		}
		return vect; // rendu vecteur
	}

	// FONCTION D'ALLOCATION D'UN VECTEUR DE FILMS DEPUIS LES DONNEES DE LA BASE
	public Vector<Film> extraire_films_BDD() throws SQLException {
		Vector<Film> vect = new Vector<Film>();// allocation du vecteur
		ResultSet resultat = obtenir_films();// recuperation des donnes de la table
		while (resultat.next()) {// allocation et ajout du nvl obj
			vect.add(new Film(string_en_vector(resultat.getString("acteur")),
					string_en_vector(resultat.getString("genres")), resultat.getString("realisateur"),
					resultat.getString("titre"), resultat.getString("synopsis"), resultat.getDouble("note"),
					resultat.getInt("duree"), resultat.getInt("ID"), resultat.getString("video"),
					resultat.getString("trailer"), resultat.getDate("parution"), resultat.getString("affiche"),
					resultat.getInt("nb_note")));
		}
		return vect; // rendu vecteur
	}

	// FONCTION D'ALLOCATION D'UN VECTEUR DE DOCUMENTAIRES DEPUIS LES DONNEES DE LA
	// BASE
	public Vector<Documentaire> extraire_documentaires_BDD() throws SQLException {
		Vector<Documentaire> vect = new Vector<Documentaire>();// allocation du vecteur
		ResultSet resultat = obtenir_documentaires();// recuperation des donnes de la table
		while (resultat.next()) {// allocation et ajout du nvl obj
			vect.add(new Documentaire(string_en_vector(resultat.getString("acteur")),
					string_en_vector(resultat.getString("genres")), resultat.getString("realisateur"),
					resultat.getString("titre"), resultat.getString("synopsis"), resultat.getDouble("note"),
					resultat.getInt("duree"), resultat.getInt("ID"), resultat.getString("video"),
					resultat.getString("trailer"), resultat.getDate("parution"), resultat.getString("affiche"),
					resultat.getInt("nb_note")));
		}
		return vect; // rendu vecteur
	}

	// FONCTION D'ALLOCATION D'UN VECTEUR DE EPISODES DEPUIS LES DONNEES DE LA BASE
	public Vector<Episode> extraire_episodes_BDD() throws SQLException {
		Vector<Episode> vect = new Vector<Episode>();// allocation du vecteur
		ResultSet resultat = obtenir_episodes();// recuperation des donnes de la table
		while (resultat.next()) {// allocation et ajout du nvl obj
			vect.add(new Episode(resultat.getInt("numero_episode"), string_en_vector(resultat.getString("acteur")),
					string_en_vector(resultat.getString("genres")), resultat.getString("realisateur"),
					resultat.getString("titre"), resultat.getString("synopsis"), resultat.getDouble("note"),
					resultat.getInt("duree"), resultat.getInt("ID"), resultat.getString("video"),
					resultat.getString("trailer"), resultat.getDate("parution"), resultat.getInt("serie"),
					resultat.getInt("saison"), resultat.getString("affiche"), resultat.getInt("nb_note")));
		}
		return vect; // rendu vecteur
	}

	// FONCTION D'ALLOCATION D'UN VECTEUR DE SAISONS DEPUIS LES DONNEES DE LA BASE
	public Vector<Saison> extraire_saisons_BDD() throws SQLException {
		Vector<Saison> vect = new Vector<Saison>(); // allocation du vecteur
		ResultSet resultat = obtenir_saisons();// recuperation des donnes de la table
		while (resultat.next()) {// allocation et ajout du nvl obj
			vect.add(new Saison(null, resultat.getInt("nombre_episode"), resultat.getInt("ID"),
					resultat.getInt("serie"), resultat.getInt("num_saison")));
		}
		return vect; // rendu vecteur
	}

	// FONCTION D'ALLOCATION D'UN VECTEUR DE SERIES DEPUIS LES DONNEES DE LA BASE
	public Vector<Serie> extraire_series_BDD() throws SQLException {
		Vector<Serie> vect = new Vector<Serie>(); // allocation du vecteur
		ResultSet resultat = obtenir_series();// recuperation des donnes de la table
		while (resultat.next()) {// allocation et ajout du nvl obj
			vect.add(new Serie(resultat.getInt("nombre_saison"), null, string_en_vector(resultat.getString("acteur")),
					string_en_vector(resultat.getString("genres")), resultat.getString("realisateur"),
					resultat.getString("titre"), resultat.getString("synopsis"), resultat.getDouble("note"),
					resultat.getInt("duree"), resultat.getInt("ID"), resultat.getString("video"),
					resultat.getString("trailer"), resultat.getDate("parution"), resultat.getString("affiche")));
		}
		return vect; // rendu vecteur
	}

	// FONCTION D'ALLOCATION D'UN VECTEUR DE SERIES DEPUIS LES DONNEES DE LA BASE
	public Vector<Visionnage> extraire_visionnages_BDD() throws SQLException {
		Vector<Visionnage> vect = new Vector<Visionnage>(); // allocation du vecteur
		ResultSet resultat = obtenir_visionnages();// recuperation des donnes de la table
		while (resultat.next()) {// allocation et ajout du nvl obj
			vect.add(new Visionnage(resultat.getInt("ID"), resultat.getInt("ID_membre"), resultat.getInt("ID_film"),
					resultat.getInt("ID_documentaire"), resultat.getInt("ID_serie"), resultat.getInt("ID_saison"),
					resultat.getInt("ID_episode"), resultat.getInt("time_code")));
		}
		return vect; // rendu vecteur
	}

	// FONCTION D'INSERTION D'UN MEMBRE DANS LA BDD
	public void ajouter_membre_BDD(Membre membre) {
		// reception du membre à inserer en parametres
		this.connexion.executer_maj(
				"INSERT INTO NETFLIX.membres (nom, prenom, adresse_mail, telephone, num_carte, preferences, mdp, admin, temps_visionnage, nb_film_vu, soustitre, reprise, qualite) VALUES ( "
						+ membre.toString_sql_insert()); // execution de la commande
	}

	public void maj_parametre_BDD(Membre membre) {
		// reception du visionnage à inserer en parametres
		this.connexion.executer_maj("USE netflix;");

		this.connexion.executer_maj("UPDATE membres SET soustitre = " + membre.isSoustitre() + ", reprise ="
				+ membre.isReprise() + ", qualite = \"" + membre.getQualite() + "\" WHERE ID=" + membre.getID() + ";"); // execution
		// de
		// la
		// commande

	}

	public void maj_stats_BDD(Membre membre) {
		// reception du visionnage à inserer en parametres
		this.connexion.executer_maj("USE netflix;");
		System.out.println("UPDATE membres SET nb_film_vu = 0, temps_visionnage = 0 WHERE ID=" + membre.getID() + ";");
		this.connexion.executer_maj(
				"UPDATE membres SET nb_film_vu = 0, temps_visionnage = 0 WHERE ID=" + membre.getID() + ";"); // execution
		// de
		// la
		// commande

	}

	// FONCTION D'INSERTION D'UN VISIONNAGE DANS LA BDD
	public void ajouter_visionnage_BDD(Visionnage nv_visionnage) {
		// reception du visionnage à inserer en parametres
		this.connexion.executer_maj(
				"INSERT INTO NETFLIX.visionnages (ID_membre, ID_film, ID_documentaire, ID_serie, ID_saison, ID_episode, time_code) VALUES ( "
						+ nv_visionnage.toString_sql_insert()); // execution de la commande
	}

	public void maj_visionnage_BDD(ContenuCinematographique contenu, Membre user, int temps, boolean fin) {
		this.connexion.executer_maj("USE netflix;");

		if (contenu.who_am_i() == "film") {
			if (!fin) {
				this.connexion.executer_maj("UPDATE visionnages SET time_code = " + temps + " WHERE ID_membre="
						+ user.getID() + " AND ID_film =" + contenu.getID() + ";");
				System.out.println("UPDATE visionnages SET time_code = " + temps + " WHERE ID_membre=" + user.getID()
						+ " AND ID_film =" + contenu.getID() + ";");
			} else
				this.connexion.executer_maj("UPDATE visionnages SET time_code = -1 WHERE ID_membre=" + user.getID()
						+ " AND ID_film =" + contenu.getID() + ";");
		}
		if (contenu.who_am_i() == "documentaire") {
			if (!fin)
				this.connexion.executer_maj("UPDATE visionnages SET time_code = " + temps + " WHERE ID_membre="
						+ user.getID() + " AND ID_documentaire = " + contenu.getID() + ";");
			else
				this.connexion.executer_maj("UPDATE visionnages SET time_code = -1 WHERE ID_membre=" + user.getID()
						+ " AND ID_documentaire = " + contenu.getID() + ";");
		}
		if (contenu.who_am_i() == "episode") {
			Episode ep = (Episode) contenu;
			if (!fin)
				this.connexion.executer_maj("UPDATE visionnages SET time_code = " + temps + " WHERE ID_membre="
						+ user.getID() + " AND ID_serie = " + ep.getID_serie() + " AND ID_saison = " + ep.getID_saison()
						+ " AND ID_episode = " + ep.getID() + ";");
			else
				this.connexion.executer_maj("UPDATE visionnages SET time_code = -1 WHERE ID_membre=" + user.getID()
						+ " AND ID_serie = " + ep.getID_serie() + " AND ID_saison = " + ep.getID_saison()
						+ " AND ID_episode = " + ep.getID() + ";");

		}

	}

	public void maj_contenu_BDD_note(ContenuCinematographique contenu, double note, Membre user, int temps,
			boolean fin) {

		System.out.println(contenu.getNote());
		System.out.println(contenu.getnb_note());
		System.out.println(note);

		double nvlle_moyenne = (contenu.getNote() * contenu.getnb_note() + note) / (contenu.getnb_note() + 1);

		if (contenu.who_am_i() == "film") {
			this.connexion.executer_maj("USE netflix;");
			this.connexion.executer_maj("UPDATE films SET nb_note = " + (contenu.getnb_note() + 1) + ", note = "
					+ nvlle_moyenne + " WHERE ID=" + contenu.getID() + ";");
			System.out.println("use netflix ; UPDATE films SET nb_note = " + (contenu.getnb_note() + 1) + ", note = "
					+ nvlle_moyenne + " WHERE ID=" + contenu.getID() + ";");
		}
		if (contenu.who_am_i() == "documentaire")
			this.connexion.executer_maj("USE netflix;");
		this.connexion.executer_maj("UPDATE documentaires SET nb_note = " + (contenu.getnb_note() + 1) + ", note = "
				+ nvlle_moyenne + " WHERE ID=" + contenu.getID() + ";");
		if (contenu.who_am_i() == "episode") {
			Episode ep = (Episode) contenu;
			this.connexion.executer_maj("USE netflix;");

			this.connexion.executer_maj("UPDATE episodes SET nb_note = " + (contenu.getnb_note() + 1) + ", note = "
					+ nvlle_moyenne + " WHERE ID=" + ep.getID() + " AND saison=" + ep.getID_saison() + " AND serie="
					+ ep.getID_serie() + ";");

		}
		if (fin == false) {// film non terminé
			this.connexion.executer_maj("USE netflix;");
			this.connexion.executer_maj("UPDATE membres SET temps_visionnage = " + (user.getTemps_visionnage() + temps)
					+ " WHERE ID=" + user.getID() + ";");
		}
		if (fin == true) {
			// film terminé
			this.connexion.executer_maj("USE netflix;");
			this.connexion.executer_maj(
					"UPDATE membres SET nb_film_vu = " + (user.getNb_film_vu() + 1) + ", temps_visionnage = "
							+ (user.getTemps_visionnage() + temps) + " WHERE ID=" + user.getID() + ";");

		}

	}

	// GETTER DE L'INTERFACE
	public BDD_interface get_connexion() {
		return connexion;
	}

	// SETTER DE L'INTERFACE
	public void set_connexion(BDD_interface connexion) {
		this.connexion = connexion;
	}

	// FONCTION DE FORMATAGE DE STRING EN ARRAYLIST DE STRINGS
	private ArrayList<String> string_en_vector(String input) {
		ArrayList<String> list = new ArrayList<>(Arrays.asList(input.split(" ; "))); // formatage
		return list; // rendu du bon format
	}

}
